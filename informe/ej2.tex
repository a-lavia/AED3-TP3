\section{Ejercicio II: Heurística constructiva golosa}

En el problema dado, Brian necesita conocer el camino con el menor recorrido para vencer a todos los gimnasios. Cómo sabe que buscar la solución óptima puede ser muy costosa, decide por generar una \textbf{heurística constructiva golosa} para obtener de forma más rápida una solución que, si bien no es la óptima, va a intentar estar cercana a ella.

\subsection{Algoritmo}

La \textbf{heurística constructiva golosa} propuesta para obtener una solución es la siguiente: generamos caminos que sólo pasen por gimnasios, ignorando completamente las pociones y paradas, comenzando siempre desde un gimnasio distinto, y yendo al más cercano. Luego, nos quedamos con el mejor de estos caminos (el de menor distancia recorrida). 

Una vez obtenido éste camino generamos el camino solución de la siguiente forma: toma el primer gimnasio del primer camino y observa cuantas pociones son necesarias para ganarle al mismo, entonces, mientras tiene menos pociones que las necesarias busca las poke paradas más cercanas y las va agregando al camino solución hasta que paso por las suficientes paradas para ganarle al gimnasio. Cuando llega a esa cantidad sufiente de poke paradas, pasa por el gimnasio, lo vence y lo agrega al camino solución.

Luego, repite lo mismo para los siguientes gimnasios.

El algoritmo termina si, o bien le ganó a todos los gimnasios, caso en el que devuelve la distancia recorrida, cantidad de gimnasios y poke paradas que recorrió y el camino realizado; o si llega a un punto donde no puede ganarle a ningún gimnasio y tiene la mochila llena o pasó por todas las poke paradas, devolviendo $-1$.


Con todo esto descripto anteriormente, el pseudocódigo del algoritmo propuesto es el siguiente:

\begin{algorithm}[H]
\label{}
\caption{}
\begin{algorithmic}[1]
\Statex \underline{Entrada}: \textbf{Mochila}: entero, \textbf{Gimnasios}: vector, \textbf{Paradas}: vector

\State cola Solución $\leftarrow$ Vacia()
\State entero Pociones $\leftarrow$ 0
\State lista CaminoGimnasios $\leftarrow$ ConstruccionCaminoGimnasios(gimnasios)

\While{Mientras hay Gimnasios en CaminoGimnasios}

	\While(Mientras Pociones $<$ PocionesNecesarias(Siguiente(CaminoGimnasios)))

		\State Pokeparada $\leftarrow$ ObtenerMejorPokeparada(Siguiente(CaminoGimnasios), Paradas)
		\State Encolar(Solución, Pokeparada)
		\State Pociones $\leftarrow$ Minimo(Pociones+3, Mochila)

	\EndWhile

	\State Pociones $\leftarrow$ Pociones - PocionesNecesarias(Siguiente(CaminoGimnasios))
	Encolar(Solución, Siguiente(CaminoGimnasios))

\EndWhile

\State Devolver Solución

\medskip
\Statex \underline{}
\end{algorithmic}
\end{algorithm}

Para generar el camino de gimnasios lo que hacemos es: comenzando por cada gimnasio, vamos obteniendo siempre el de distancia menor a este hasta que no quedan más gimnasios por recorrer y agregamos la lista generada dentro de un conjunto. Una vez que hicimos este procedimiento, en el conjunto tendremos todos los camimos de gimnasios generados con este procedimiento y devolvemos el que posée distancia menor. El pseudo código de esta operación es el siguiente:

\begin{algorithm}[H]
\begin{algorithmic}
\Statex \underline{Entrada}: \textbf{Gimnasios}: vector

\State Conjunto ConjCamino $\leftarrow$ Vacio()

\For{Para todo g Gimnasio en Gimnasios}

	\State Lista Camino $\leftarrow$ Vacia()
	\State Candidatos $\leftarrow$ Todos los gimnasios
	\While{Mientras hay gimnasios por agregar al camino}

		\State gym $\leftarrow$ ObtenerGimnasioMasCercano(Candidatos)
		Agregar(ConjCamino, gym)

	\EndWhile

\EndFor

\State DevolverCaminoMasCorto(ConjCamino)

\medskip
\Statex \underline{}
\end{algorithmic}
\end{algorithm}


Y con esto termina nuestro algoritmo propuesto.

Para no agobiar con tanto código, en esta sección no ahondaremos en el resto de las funciones auxiliares, que consideramos de por si declarativas, pero si haremos un análisis profundo de ellas en la siguiente sección donde analizaremos la complejidad del código.


\subsection{Complejidad}

El orden de complejidad de nuestra \textbf{heurística constructiva golosa} es de \bigo{|gimnasios|^3 + |paradas|^2 }. Veamos como lo obtuvimos:

Lo primero que realizamos es generar el camino más corto de gimnasios. La función que se encarga de esta operación es \textbf{heuristicaVecinoCercano}. Dentro de ella, comenzando por cada gimnasio, generamos una lista de todos éstos menos el del comienzo. Entonces, tomando el gimnasio del comienzo como actual, iteramos en la lista cual es el gimnasio más cercano al actual, cuando lo obtenemos lo encolamos sobre el camino y asignamos como actual a este último encontrado.

Ir generando el camino con distancia más corta de un gimnasio nos da como complejidad \bigo{|gimnasios|^2} ya que por cada uno tenemos que buscar entre los demás cual tiene menor distancia para agregar al camino. Y, como esto se realiza por cada gimnasio, la complejidad total de esta función es \bigo{|gimnasios|^3}

Luego, se realiza una busqueda por cada gimnasio del camino generado por la función anterior, la cantidad de paradas necesarias para ganarle. Ésta operación la realizamos en la función \textbf{heuristicaParadasCercanas}. Basicamente lo que hace es lo siguiente, tomamos del camino generado por la función anterior el primer gimnasio y observamos cual es la cantidad de pociones necesarias para ganarle. Entonces, mientras en la mochila no tengamos esa cantidad de pociones vamos a las paradas más cercanas del gimnasio hasta tener las suficientes. En nuestra función tenemos un vector con las posiciones de todas las paradas y una lista con los índices de las que no fueron visitadas. Cuando se visita alguna parada, se quita el índice de la lista. En peor caso, un gimnasio para ser vencido puede necesitar tantas pociones como $|paradas|*3$, entonces, en este caso, iría buscando la poke parada más cercana que no visito dentro de la lista y quitandolas hasta ésta quedar vacía. La complejidad de esta operación es \bigo{\frac{|paradas|^2 + |paradas|}{2}} = \bigo{|paradas|^2}. En mejor caso, no sería necesario ir a alguna poke parada para ganarle a los gimnasios (porque estos necesitan cero pociones para ganarles), entonces no se buscaría ninguna parada. 
Esto da la idea que la complejidad de este código termina siendo \bigo{|gimnasios| + |paradas|^2} ya que recorre a todos los gimnasios y, en peor caso, recorrería todas las paradas siempre buscando la de distancia menor.

Por último, tenemos la función \textbf{imprimirSolucion} que toma el camino de la solución. Se calcula la distancia total mirando todos los elementos del camino, esto con complejidad \bigo{|paradas| + |gimnasios|} y, luego, se van desencolando los índices de los gimnasios y paradas recorridos imprimiendolos, esto también con complejidad \bigo{|paradas| + |gimnasios|}. Entonces, la complejidad de esta función es \bigo{|paradas| + |gimnasios|}.


Con todo esto calculado, la complejidad total esta dada por la suma de las complejidades de estas tres funciones: \bigo{|gimnasios|^3} + \bigo{|gimnasios| + |paradas|^2} + \bigo{|paradas| + |gimnasios|}. 

Como \bigo{|gimnasios|} $\subset$ \bigo{|gimnasios|^3} y \bigo{|paradas|} $\subset$ \bigo{|paradas|^2}, entonces la complejidad final es: \bigo{|gimnasios|^3} + \bigo{|paradas|^2} = \bigo{|gimnasios|^3 + |paradas|^2}

\subsubsection{Estructuras utilizadas de la \textit{Standard Template Library} de C++}

Para complementar porque las complejidades son las dadas, en nuestra implementación utilizamos tres estructuras de la \textit{Standard Template Library} de C++: \emph{queue}\footnote{\url{http://www.cplusplus.com/reference/queue/queue/}}, \emph{vector}\footnote{\url{http://www.cplusplus.com/reference/vector/vector/}} y \emph{list}\footnote{\url{http://www.cplusplus.com/reference/list/list/}}.

De la estructura \emph{queue}, las funciones que utilizamos son: push\footnote{\url{http://www.cplusplus.com/reference/queue/queue/push/}}, pop\footnote{\url{http://www.cplusplus.com/reference/queue/queue/pop/}}, front\footnote{\url{http://www.cplusplus.com/reference/queue/queue/front/}}, size\footnote{\url{http://www.cplusplus.com/reference/queue/queue/size/}} y empty\footnote{\url{http://www.cplusplus.com/reference/queue/queue/empty/}}, donde la complejidad de las mismas es de tiempo constante.

De la estructura \emph{vector}, las funciones que utilizamos son: size\footnote{\url{http://www.cplusplus.com/reference/vector/vector/size/}} y el operador [ ] que devuelve el elemento i-ésimo\footnote{\url{http://www.cplusplus.com/reference/vector/vector/operator[]/}}, donde sus complejidades son de tiempo constantes.

De \emph{list}, utilizamos las funciones remove\footnote{\url{http://www.cplusplus.com/reference/list/list/remove/}} que tiene complejidad lineal, y push\_back\footnote{\url{http://www.cplusplus.com/reference/list/list/push_back/}} que tiene complejidad constante.


\subsection{Experimentación}

