\section{Ejercicio III: Heur\'istica de b\'usqueda local}

\subsection{Introducci\'on}
\label{sec:ej3_intro}
B\'usqueda local es un m\'etodo que parte de una soluci\'on no \'optima a un problema e intenta mejorarla a trav\'es de modificaciones, es decir, convirti\'endola en una soluci\'on \textit{vecina}. Luego, es necesario determinar qu\'e constituye una soluci\'on vecina a otra dada, hay que definir un \textit{vecindario}. Por ejemplo, en nuestro problema a resolver, donde una soluci\'on s* es un camino simple, que cumple ciertas condiciones, entre algunos nodos de un grafo, una soluci\'on vecina s a s* podr\'ia ser un camino id\'entico al de s* excepto por un nodo que se reemplaza con otro que s* no recorre.

Presentamos a continuaci\'on un pseudoc\'odigo que ilustra la idea general de este algoritmo, en \'el asumimos que queremos minimizar f(s) donde s es una soluci\'on y f una funci\'on que la eval\'ua.

\begin{algorithm}[H]
\label{}
\caption{Idea general de b\'usqueda local}
\begin{algorithmic}[1]
\Statex \underline{Entrada}: S un conjunto de soluciones, N una funci\'on que devuelve las soluciones vecinas a otra dada y f una funci\'on que eval\'ua una soluci\'on
\medskip
\State s* $\gets$ s $\in$ S
\While{($\exists$ s $\in$ N(s*)) f(s) $<$ f(s*)}
    \State s* $\gets$ s $\in$ N(s*) tal que f(s) $<$ f(s*)
\EndWhile
\medskip
\Statex \underline{Salida}: s*
\end{algorithmic}
\end{algorithm}

\subsection{Estructuras}
Para implementar una heur\'istica de b\'usqueda local para nuestro problema utilizamos una clase llamada \texttt{Camino} que est\'a formada por una instancia de la clase \texttt{Grafo}, el tamaño de la mochila, la distancia computada hasta el momento y un puntero al primer nodo visitado en el recorrido actual, que es un elemento de tipo \texttt{Nodo}.

La clase \texttt{Grafo} est\'a compuesta por un vector de instancias de tipo \texttt{Nodo} y una matriz con la distancia entre cada par de nodos. Esta distancia se corresponde con la distancia euclideana\footnote{\url{https://es.wikipedia.org/wiki/Distancia_euclidiana}} calculada utilizando sus coordenadas.

Cada nodo tiene un n\'umero de identificaci\'on, sus coordendas x e y, la cantidad de pociones que demanda u otorga, un valor booleano que indica si el nodo representa a un gimnasio, un puntero a su nodo anterior y otro a su nodo siguiente dentro del camino actual.

Luego, utilizando las estructuras descriptas anteriormente, realizamos una implementaci\'on que \textit{soporta} dos criterios distintos de vecindad.

\subsection{Vecindad I: Permutaci\'on del camino}
En este vecindario establecemos que s* es una soluci\'on vecina a s si el camino de s* se puede obtener permutando el orden en el que se recorren dos nodos en s. Este criterio se conoce comunmente como \textit{swap}.

\subsection{Vecindad II: Permutaci\'on y reemplazo de las pokeparadas}
Este criterio considera que s* es una soluci\'on vecina a otra s si el camino de s* es igual al de s* luego de permutar el orden en el que se recorren dos pokeparadas, o reemplazar una pokeparada del camino por otra que no se encontraba en \'el.

Elegimos este vecindario suponiendo que una heur\'istica golosa podr\'ia encontrar un buen camino entre los gimnasios pero tendr\'ia dificultades estableciendo los \textit{desv\'ios} para buscar pociones.

\subsection{Algoritmo}
Como explicamos en la secci\'on \ref{sec:ej3_intro}, para realizar una b\'usqueda local tomamos una soluci\'on incial que luego es \textit{mejorada}. Para esto decidimos utilizar el algoritmo goloso desarrollado en el segundo ejercicio.

Adem\'as, optamos por considerar tambi\'en las soluciones que devuelven una misma distancia final una vez que no podemos encontrar soluciones vecinas que reduzcan m\'as ese n\'umero. Esperamos que en algunos casos esto nos permita hallar mejoras nuevas. Para evitar entrar en ciclos infinitos, por ejemplo, donde vamos de una soluci\'on s* a otra s equivalente, y de ella nuevamente volvamos a s*, utilizamos un diccionario donde tenemos como clave la identificaci\'on de un nodo y como significado un conjunto con las identificaciones de los nodos que fueron permutados o reemplazados por el primero. De esta manera tambi\'en limitamos la cantidad de soluciones equivalentes para analizar.

Todo lo descripto anteriormente se encuentra resumido en el siguiente pseudoc\'odigo:

\begin{algorithm}[H]
\label{}
\caption{B\'usqueda local}
\begin{algorithmic}[1]
\Statex \underline{Entrada}: camino : \texttt{Camino} y criterio : \texttt{Vecindad}
\medskip
\State camino.asignarSoluci\'onGolosa()
\If{camino.encontr\'eCamino()}
    \If{criterio == permutaCamino}
        \State nodosConsiderados $\gets$ nodos que forman el camino hallado por el algoritmo goloso
    \Else
        \State nodosConsiderados $\gets$ nodos que representan a las pokeparadas del grafo
    \EndIf
    \State busco $\gets$ true
    \State dicc(int, conj(int)) nodosCambiados $\gets$ Vac\'io()
    \While{busco}
        \While{encuentroSoluci\'onVecinaMejor(nodosConsiderados)}
            \If{\#nodosCambiados.claves() $>$ 0}
                \State nodosCambiados $\gets$ Vac\'io()
            \EndIf
        \EndWhile
        \If{$\neg$encuentroSoluci\'onVecinaIgual(nodosConsiderados, nodosCambiados)}
            \State busco $\gets$ false
        \EndIf
    \EndWhile
\EndIf
\medskip
\Statex \underline{Salida}: camino.imprimirSoluci\'on()
\end{algorithmic}
\end{algorithm}

Como podemos observar en las l\'ineas 12 y 13, si encuentro una soluci\'on que mejora la que ten\'ia vac\'io el diccionario por si ven\'ia de modificar mi camino por otro de distancia igual.

Es importante destacar que la funci\'on \texttt{encuentroSoluci\'onVecinaMejor} devuelve verdadero si encuentra una y realiza las modificaciones necesarias en mi instancia de \texttt{Camino} para transformar mi soluci\'on en esa. El comportamiento de \texttt{encuentroSoluci\'onVecinaIgual} es an\'alogo, sumando la consulta al diccionario que recibe como argumento para evitar ciclos.

\begin{algorithm}[H]
\label{}
\caption{Encuentro una soluci\'on vecina mejor}
\begin{algorithmic}[1]
\Statex \underline{Entrada}: nodosConsiderados : \texttt{vector(Nodo)}
\medskip
\State busco $\gets$ true
\For{i = 0, ..., nodosConsiderados.tamaño()}
    \For{j = 0, ..., nodosConsiderados.tamaño()}
        \If{i $\neq$ j $\land$ (est\'aEnElCamino(nodosConsiderados[i]) $\lor$ est\'aEnElCamino(nodosConsiderados[j])) $\land$ cambiarMejora(nodosConsiderados[i], nodosConsiderados[j]))}
            \State busco $\gets$ false
        \EndIf
    \EndFor
\EndFor
\medskip
\Statex \underline{Salida}: $\neg$busco
\end{algorithmic}
\end{algorithm}


\subsection{Complejidad}
% GENERAL: Deducir una cota de complejidad temporal del algoritmo propuesto (en funci ́on de los par ́ametros que se consideren correctos) y justificar por qu ́e el algoritmo desarrollado para la resoluci ́on del problema cumple la cota dada. Utilizar el modelo uniforme salvo que se explicite lo contrario

% ESTE TP: Calcular el orden de complejidad temporal de peor caso de una iteraci ́on del algoritmo de busqueda local (para las vecindades planteadas). Si es posible, dar una cota superior para la cantidad de iteraciones de la heur ́ıstica.

\subsection{Experimentación}
% GENERAL: Realizar una experimentacion computacional para medir la performance del programa implementado. Para ello se debe preparar un conjunto de casos de test que permitan observar los tiempos de ejecucion en funcion de los parametros de entrada. Deber ́an desarrollarse tanto experimentos con instancias aleatorias (detallando como fueron generadas) como experimentos con instancias particulares (de peor/mejor caso en tiempo de ejecuci ́on, por ejemplo). Se debe presentar adecuadamente en forma grafica una comparaci on entre los tiempos medidos y la complejidad te ́orica calculada y extraer conclusiones de la experimentaci ́on.
% una experimentacion b ́asica que muestre que la cota planteada de complejidad tiene sentido.
% algun experimento que muestre que el mejor caso es bueno y el peor caso es malo.
% otros experimentos que les parezcan relevantes y pongan de manifiesto alguna caracter ́ıstica del algoritmo (que ya deber ́ıan haber comentado en algun lado).
% una explicacion y justificacion de como van a hacer el experimento (como van a generar las instancias de prueba, cu ́antas corridas de cada uno van a tomar, etc.)

% ESTE TP: Realizar una experimentacion que permita observar la performance del algoritmo comparando
% los tiempos de ejecucion y la calidad de las soluciones obtenidas, en funci ́on de las vecindadeS utilizadas y elegir, si es posible, la configuraci ́on que mejores resultados provea para el grupo de instancias utilizado.